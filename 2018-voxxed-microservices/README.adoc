= Voxxed days Microservices
Thomas SCHWENDER <https://github.com/ardemius[@ardemius]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: images
:source-highlighter: highlightjs
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 2
// To turn off figure caption labels and numbers
//:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
:caption:

toc::[]

Du 29 au 31/10/2018, à l'espace Charenton à Paris. +
Site : https://voxxeddays.com/microservices/

== Monday

=== Welcome to Voxxed Days Microservices

Presented by Antonio GONCALVES.

Pour les tables rondes (panel), on peut poser des questions aux panelistes via les hashtages `#MicroServices` and `#panel`

.Plan de lieux et sponsors
image::voxxed_place_map.jpg[]

*Wifi* : SSID "Espace Charenton Fibre" : / mdp : CharentonfibreFibre#Paris12

Parmi les partenaires :

* Manning : on *ctwvoxxed18* pour avoir 40% de réduction sur tous les livres Manning
* Comme pour Devoxx France, *321IdCom* est partenaire pour la comm de l'évènement (c'est une des boîtes utilisée pour les goodies de Devoxx France)

*Twitter* : @vxdmicroservice

=== Distant Past of Microservices

Presentedy by *Ken Finnigan*, Senior Principal Software Engineer for *Red Hat* Middleware.

==== Abstract

Microservices, distributed systems in sheep's clothing, have been around in various forms since the 1960s! We trek down amnesia lane, finding that what we’re doing has been done before, but the names and tools have changed.

Whether it’s Netflix OSS, Spring Cloud, or any other open source framework for microservices, we’ve likely experienced using them all at one point. What have using these frameworks taught us? Do they help or hinder us? Is Service Mesh the answer? I’ll explore these questions as we meander along a journey through the past.

==== Notes

When speaking of microservices, we are speaking of *distributed systems*

Ken : client / server architecture is just another distributed system

*Characteristics of microservices* :

* retries
* transaction manager
* Command objects
* service registry
* caching

Ken cite (comme tout le monde) *Istio* pour la gestion de l'environnement associé aux microservices.

[quote, Ken]
____
We have to stop reinventing the same wheel, just because we can...
____

.Consistent state
image::voxxed_01.jpg[]

Ken vient de "Enterprise Java Microservices" chez Manning.

=== distributed: of systems and teams

Presented by *Bridget Kromhout*, Principal Cloud Developer Advocate at Microsoft.

==== Abstract

We endeavor to build consistency, availability, and fault tolerance into our distributed systems, but how do we build them into our teams? The human factors in microservices require as much attention as do our technical implementations.

Drawing in comparisons from theoretical computer science and practical systems implementation, I’ll explore how building understanding requires a practical application of great tools in a deliberate pursuit of a constructive culture.

==== Notes

____
We replace our monolith with microservices so that every outage could be more like a murder mystery
____

.CAP theorem
image::voxxed_02.jpg[]

.Reminder
NOTE: *CAP theorem* : trade-off between *Consistency / Availability / partition tolerance*

==== Consistency

Bridget remembering a startup going to Docker in PROD in 2013 (!). +
For which reasons? -> *more consistent deployments, more repeatable ones*

Containers don't solve all problems

*Helm*: the package manager for Kubernetes +
"Help is the best way to find, share, and use software built for Kubernetes"

image::voxxed_03.jpg[]

==== Availability

Kubernetes: a choice for orchestration 

* portable
* extensible
* self-healing

Tools to check : *Draft*, *Brigade*, *Virtual Kubelet*

.Virtual Kubelet
image::voxxed_04.jpg[]

Orchestrating containers is a tool, *NOT* a goal! +
-> If no benefit, don't do it

==== Partition tolerance (or Fault tolerance)

[quote, Loi de Conway]
____
Any organization that designs a system.... will produce a design whose structure is a copy of the organization's *communication* structure
____

* *Monitoring* is for operating software/systems
* *Insturmentation* is for wrting software
* *observability* is for understanding systems.

_Winter is coming_ -> k8s getting real

=== Preparing For a Future Microservices Journey

Presented by Susanne Kaiser, independent Tech Consultant.

==== Abstract

In the light of rapidly changing market requirements organizations must accelerate to excel in the market. A 4-years research (by Nicole Forsgren, Jez Humble and Gene Kim) has revealed that software delivery performance has a strong impact on profitability, productivity and market share of technology organizations. +
Loosely coupled architecture, such as promoted by microservices, and empowered teams are some of the capabilities to improve software delivery performance. 

After having already introduced microservices in a startup context I would like to share some thoughts what to do differently when introducing microservices next time in the future.

==== Notes

Quite a journey to move to monolith to microservices

.Microservices required components
image::voxxed_05.jpg[]

____
Build the things that differentiate you, offload the things that don't
____

.Cloud native
image::voxxed_06.jpg[]

.Kubernetes
image::voxxed_07.jpg[]

.Cloud native citizen principles
image::voxxed_08.jpg[]

Importance of the separation of concerns -> with the use of *Service Mesh*

image::voxxed_09.jpg[]

And now *Serverless* principles

image:voxxed_10.jpg[]
image:voxxed_11.jpg[]

.Serverless example with image processing
image::voxxed_12.jpg[]

=== Hexagonal at Scale, with DDD and microservices!

Presented by Cyrille MARTRAIRE, CTO and partner at Arolla.

==== Abstract

*Microservices need DDD absolutely*. +
Bounded Contexts, a key DDD ingredient, is the tool of choice to define services boundaries that won’t end up in a complete disaster at runtime and at deployment time. And for a given service, the Hexagonal Architecture is a great implementation style as well.

In this talk, you’ll get a deeper understanding of what these abstract buzzwords are all about, illustrated with short Java code. You’ll discover how to really split your monolith correctly, and when to go Hexagonal, or not, because one should never abuse of the good things. It will be fun, with perhaps a few surprises as well!

==== Notes

* Split by technology +
Also wrong...
* Split by entity +
Still wrong, even if the most common...

So how to define our Bounded Contexts correctly? +
*By (sub-)domain*

image::voxxed_13.jpg[]

-> This alignment is just what we want. +
But we only know *afterwards* that our boundaries where right

We want to partition things into *independent* things.

*Strategic design* = in the *long* term

See this example, with a very bad add of a 2nd address in the class :

image::voxxed_14.jpg[] 

-> At term, it will *NOT* be maintainable.

In this other example : Customer is not Account is not Recipient, EVENT IF THEY LOOK LIKE EACH OTHER! +
*not to be* means (most of the time) different Bounded Contexts.

-> *DRY PLUS coupling OR isolation PLUS redundancy*

In the former customer, account, recipient factorizing common attributes (like address) means coupling. +
Moreover, it is not because things look like each other that they are the same thing (meaning the same BC) +
-> duplication (same address in several different BC) can be a good thing or even a required thing.

.High coupling and low cohesion
image::voxxed_15.jpg[]

Every pb on a coupled element will propagate to the whole application.

With this alternative, we now only rely on "shipping" -> low coupling, better cohesion

image::voxxed_16.jpg[]

Mapping = ACL (Anti COrruption Layer) in DDD

.Good and bad architecture
image::voxxed_17.jpg[]

Now, how do we identify the Bounded Contexts?

* DIfferent Company Departments -> different Bounded Contexts
* Different USAGE of the same thing -> different Bounded Contexts
+
image::voxxed_18.jpg[]

Like in a dictionary, a same word can have different meanings in different contexts.

image::voxxed_19.jpg[]

Good domains generally end with "-ing" or "-tion" (because *purpose verbs* made into nouns)

When using Event Storming, do it for *Big Things*

image::voxxed_20.jpg[]

* "Search" is always a bounded context on its own.
* Same thing for "Reporting"

Do not mandatorily split your monolith *too soon*, wait a bit to know it better

===== Hexagonal architecture

Indeed a good thing, but introduce some complexity.

To compensate that:

* Hexagonal light
* CRUD: most of the time, instead of unnecessary complexity, go CRUD!

To illustrate the need for isolation, and so microservices

image::voxxed_21.jpg[]

-> on the right, if something goes rotten, it will not contaminate the other things

You can also have *BFF* (Backend for Frontend)

*CONCLUSION*: Invest some time in learning DDD, hexagonal architecture, because they are fundamentals and reusable skills

=== Accelerate your CI/CD on Kubernetes with Jenkins X

Presented by *James Strachan*, one of the founders of Jenkins X, also created the Groovy programming language and the Apache Camel integration framework.

==== Abstract

We all want to become high performing teams delivering real business value quickly! This talk will show you how you can go faster by automating:

* setting up your CI/CD so you can spin up new microservices in seconds
* packaging of your application as container images and helm charts so it can be deployed easily on any cluster
* automatic or manual promotion of your application through Testing, Staging and Production via GitOps
* using Preview environments to get fast feedback on code changes at Pull Request before you merge them and without blocking urgent bug fixes

After watching this talk you should be able to accelerate your delivery of microservices and go faster!

==== Notes

Advise of James: read _The science of DevOps - ACCELERATE_

.Capabilities of Jenkins X
image::voxxed_22.jpg[]

* Use version control for all artifacts
* automate your deployment process
* use *trunk based* development
* implement continuous integration
* implement continuous delivery
* use loosely coupled architecture

.How does Jenkins X help?
image::voxxed_23.jpg[]

.Install process of Jenkins X: different ways
image::voxxed_24.jpg[]

-> it uses *Google Kubernetes Engine*

.Advise from James
NOTE: : Try to *avoid mini-kube*, go straight to the cloud (as soon as possible)

What's the result? +
-> each team gets their own:

* Dev Tools environment
	** jenkins master
	** elastic pool of Kubernetes build pods
	** *Nexus + monocular (Helm application store)*
* stating env
* production env

.Different ways of importing and creating projects
image::voxxed_25.jpg[]

Pour la démo, voir le projet sur le repo GitHub de James (directement), _voxxedms_ (in repo _jstrachan_)

IMPORTANT: James insiste sur l'intérêt de faire un max de test sur les branches de PR plutôt que sur le master (qui peut-être broken)

image::voxxed_26.jpg[]

.Resources
image::voxxed_27.jpg[]

-> in those links, there is the one of their very active Slack channel

NOTE: James, comme bien d'autres, fait ses slides sur la suite Google. +
De plus en plus, on se retrouve soit avec des slides Asciidoctor, soit avec des slides Google

=== Monolith 2 MicroServices - Houston we've got a problem !

Presented by *Mike Francois*

==== Abstract

Monolith to Microservices is a move from the complexity of one block into the runtime environment. Companies make a common mistake to think that they can implement microservices without upskilling efficiently their developers and getting them on an appropriate learning curve. Another mistake is that the IT department is often working on their own when the involvement of other departments is a key to success in this migration. Additionally, IT usually lacks clear roadmaps and a real incremental and iterative approach.

Most of the time, companies develop a Hype Driven Development syndrome with often only superficial knowledge and without having defined the right segregation of concerns in an environment ( monitoring, service discovering, circuit breaker, containers, etc. ). They give in to mature in-vogue architectures without solid prerequisites leading them early on to a complex architecture system (agnosticity, etc.) and decisions over the architecture set without a clear definition of boundaries and real needs (where, when, how to’s).

We will see how my customers managed to get out of their migration nightmare successfully by changing their approach.

==== Notes

-> Not done (was eating !)

=== Stop reinventing the wheel with Istio

Presented by *Mete Atamel*, a Developer Advocate at Google, focused on helping developers with Google Cloud.

==== Abtract

Containers provide a consistent and reproducible environment to run our services. +
Orchestration systems like Kubernetes help us to manage and scale our container cluster with a consistent API. +
This is a good start for a loosely coupled microservices architecture but it is not enough. 

How do you control the flow of traffic and enforce policies between services? How do you visualize service dependencies and quickly identify issues? How can you provide verifiable service identities, handle and test for failures? +
You can implement your own custom solutions or you can rely on Istio, an open platform to connect, manage and secure microservices. 

In this talk, we will take a look at some of the key capabilities of Istio and see how it can help with your microservices network.

==== Notes

The need for *Istio*

1st a reminder about containers:

image::voxxed_28.jpg[]

But *containers are not enough*:

image::voxxed_29.jpg[]

And hence the use of *Kubernetes*

image::voxxed_30.jpg[]

-> Kubernetes manages *applications*, NOT machines

Finally, for *microservices in Kubernetes world*:

image::voxxed_31.jpg[]

But *Kubernetes is not enough either*!

image::voxxed_32.jpg[]

And so we have *Istio*: +
-> *An open framework for connecting, securing, managing and monitoring services*.

Its goal:

* community maturing and gathering around common tools
* decouple application code from underlying platform and policies

.Service architecture with Istio
image::voxxed_33.jpg[]

To have Istio, first you need to have a Kubernetes cluster.

.Istio in one slide
image::voxxed_34.jpg[]

* metrics can be seen with Graphana
* trace spans with Zipkin

.Istio architecture
image::voxxed_35.jpg[]

* On voit l'usage de *Envoy* (à la place de Zuul ou Ribbon)

image::voxxed_36.jpg[]
image::voxxed_37.jpg[]

We can install Istio without all its components (without dealing with Mixer or Pilot by example)

Gateway is where you accept traffic in your service mesh.

Istio add-ons

* Graphana
* Jaeger / Zipkin

Istio features:

image::voxxed_38.jpg[]

[NOTE]
====
*New Routing API*: only from v1alph3 (O.8.0)

image::voxxed_39.jpg[]
====

*Resources*:

image::voxxed_40.jpg[]

=== Data in a Microservices world: from conundrum to options

Presented by *Emmanuel BERNARD*, Chief Architect for data stuff at Red Hat Middleware, and *Madou COULIBALY*.

==== Abtract

Microservices are great, problems arise when you start to have two of them and when you want to deal with data :)

Pun aside, data and state is a big subject that is largely ignored when discussing Microservices.

* Conundrum #1 : What is the aimed data architecture in a perfect Microservices architecture?
* Conundrum #2 : How do you share state between instances of a given Microservice in a stateless 12 factor approach?
* Conundrum #3 : how to echange state between Microservices that must remain independent?
* Conundrum #4 : how do I go from my brownfield database to a fleet of Microservices IRL without a Big Bang?
* Conundrum #5 : with many Microservices touching many data sets, how do I guarantee uniformed security (GDPR anyone)?

And the list goes on. This presentation is an opinionated answer to these questions. And yes we do demo these concepts.

==== Notes

.Microservices architecture benefits
image::voxxed_41.jpg[]

Monolith to microservices +
-> To data velocity

Benefits of *data virtualization* (here with *Teiid*) :

image:voxxed_42.jpg[]
image:voxxed_43.jpg[]

* Virtual DB doesn't really store data

image::voxxed_44.jpg[]

* Still with this last schema, if we wan't to rollback, we didn't touch the legacy DB

Now *Data security*, important point today, especially because of *regulatory constraints*

image:voxxed_45.jpg[]
image:voxxed_46.jpg[]

* main piece here is *data firewall*

===== Demo (breaking the monolith)

image::voxxed_47.jpg[]

.Breaking up the monolithic database *virtually*
image::voxxed_48.jpg[]

The *virtual DB* is defined with an XML file.

The whole demo is deployed on OpenShift.

Our microservices will be built on top of those virtual DBs.

===== how do we share the state in a stateless application?

.the challenge of state
image::voxxed_49.jpg[]

-> there is a service to do that (with *Infinispan*)

image:voxxed_50.jpg[]
image:voxxed_51.jpg[]

-> *advantages*: complexity outside the app / low latency / cross data center replication

===== Caching

As says Emmanuel: _One service to fail them all..._

-> Again, use a service to do that (still Infinispan)

image::voxxed_52.jpg[]

===== CQRS and more

Now that we went a bit further in our migration towards microservices, let's consider the following:

image::voxxed_53.jpg[]

*CDC* (Change Data Capture) to the rescue

image::voxxed_54.jpg[]

* *Debezium* is based on *Kafka* and *Kafka Connect* (check the "Real time DB change (CDC)" in the last schema)

*Conclusion*:

image::voxxed_55.jpg[]

* Take a pragmatic approach and *break up large data sources logically*
* delegate data handling to specialized services (out of the app)

.Resources
image::voxxed_56.jpg[]

=== Habitat: Automation that travels with the app

Presented by *Romain Sertelon*

==== Abstract

There are a plethora of build tools and package managers out in the universe, but no one way to ensure a happy path from local development to production when you have a micro service architecture.

This talk explains why Habitat was created, as an open source application automation engine, and how you can use it to build and ship your applications to any infrastructure with the same guarantees.

We'll go over existing build tools, their pro's and con's, industry best practices, and what Habitat adds to the mix.

==== Notes

Context at Habitat: migration from monolith to microservices

* 4 years
* 2 developpers
* simplest infrastructure possible
	** 2 envs
	** 8 services
	** "container" tarballs
	** manual deployment each sprint

More was needed on the *infra side*:

* "no more SSH"
* config management
* continuous deployment
* infrastructure agnostic tooling (to adapt easily to infra changes)

And hence the use of *Habitat project*, which is *backed by CHEF*.

.Habitat innovative vision (application automation)
image::voxxed_57.jpg[]

How is it done:

* Encapsulates and automates your application
* package management

Docker is the only thing required as prerequisite by Habitat.

.Conclusion
image:voxxed_58.jpg[]
image:voxxed_59.jpg[]

=== A Software Architect's Approach towards SPA-Based Micro Apps

Presented by *Manfred Steyer*.

==== Abtract

Even though Microservices are a very popular nowadays, many people are left wondering how single-page applications fit into this. This session taps a software architect's perspective to answer this question.

Using several examples and case studies, we explore different approaches. By discussing the pros and cons of each approach from the perspective of an JavaScript developer you will see which approach works best where. The session ends with a decision tree to help you select the right solution for your specific project.

==== Notes

Not done

=== State or events? Which shall I keep?

Presented by *Jakub Pilimon* and *Kenny Bastani*, both from Pivotal.

==== Abstract

Tired of fancy abstractions without actual down to earth implementation? +
In this talk we will go through both benefits and problems by implementing a real example of event-sourced model. 

This is a full-time live coding and we will develop features in parallel - one of us in a classic ORM-based way and the other one using event sourcing. We are going to tackle the problems step by step in both solutions from various perspectives.

From the point of view of the stakeholders our software should have quick time to market, ability to do complex data reporting and fast way to extend and to deploy new features. +
On the other hand, our fellow developers would be interested in learning curve when it comes to event sourcing and how it differs in turns of e.g. unit testing. 

At the end of each step it will be clear what kind of problems/benefits we have using one of two models. +
The talk is going to cover a broad set of buzzwords like: *event sourcing*, *CQRS*, *distributed systems*, *spring cloud stream*, *eventual consistency*, *unit testing* and *zero downtime deployments*.

==== Notes

Not done

=== Ask the architects

Presented by Ken Finnigan, Bridget Kromhout, David Schmitz and Susanne Kaiser.

== Tuesday

=== Reactive design patterns for microservices on multicore

Presented by *Charly Bechara*, and *Alain Habra* from Tredzone

==== Abstract

Most of the challenges encountered when designing microservices are solved using concurrent design patterns. However, these patterns usually do not take into account the multicore issues and possible optimizations. This is a hard requirement for real-time mission-critical applications, such as a trading platform.

This talk will cover best practices for building Reactive design patterns optimized for multicore. To achieve this, we’ll be using the actor model as implemented in our runtime Simplx: https://github.com/Tredzone/simplx

We will present use-cases related to our experience working with Euronext on the next generation trading platform. We will show how to obtain throughput scalability with the number of cores, while keeping the end-to-end latency stable.

C/C++ and Java knowledge is helpful but not required to enjoy this talk.

==== Notes



=== Integrating microservices by accepting the data dichotomy

Presented by *Damien Gasparina*, engineer and an open-source enthusiast working for Confluent.

==== Abstract

When building a microservices-based systems, we don’t generally think too much about data. If we need data from another service, we ask for it. This pattern works well for whole swathes of use cases, particularly ones where datasets are small and requirements are simple. But real business services have to join and operate on datasets from many different sources and this can be slow and cumbersome in practice.

These problems stem from an underlying dichotomy. Data systems are built to make data as accessible as possible - a mindset that focuses on getting the job done. Services, instead, focus on encapsulation - a mindset that allows independence and autonomy as we evolve and grow. But these two forces inevitably compete in most serious service-based architectures.

Understanding and accepting this dichotomy is an important part of designing service-based systems at any significant scale. In this talk, we will explain how to make use of a shared, immutable sequence of records to balance data that sits inside their services with data that is shared, an approach that allows the likes of Uber, Netflix, and LinkedIn to scale to millions of events per second.

==== Notes

== Wednesday - workshop

=== Boundaries of Microservices: How to Build Them and How to Cross Them

https://vxdms2018.confinabox.com/talk/YQD-1465/Boundaries_of_Microservices%3A_How_to_Build_Them_and_How_to_Cross_Them

Presented by *Linda van der Pal*, *Régina ten Bruggencate*, *Emmanuel Bernard* and *Gunnar Morling*.

==== Defining Service Boundaries With DDD

===== Abstract

The first part of the workshop focuses on defining the borders between microservices. +
How to split up your big problem into clearly defined microservices. In real life everything is related, and seeing the individual trees in the big picture of the sprawling forest is challenging. This is where Domain Driven Design (DDD) comes to the rescue. 

After a short presentation about DDD, we’ll get hands-on with an actual problem to end up with a working program.

===== Notes



==== Data Streams to Cross Boundaries

===== Abstrat

In the second part we’ll discuss why microservices must avoid tight coupling and how they still can share data. 

Based on Kafka, Debezium and Kubernetes, our microservices will produce and consume data streams. +
We’ll also use change data capture to stream data changes directly out of a database, without any application changes needed. +
We’ll touch on how to set up Kafka clusters on OpenShift via the Strimzi project and how to monitor and tune them for performance and resilience.

===== Notes

== Buzz words

* *Service Mesh*, et plus particulièremnet *Istio* +
En voici une définition tirée de cet article d'Octo : 
+
----
Le Service Mesh désigne une plateforme chargée d’assurer la sécurité, le routage et la traçabilité des communications entre applications microservices déployées de façon dynamique dans des conteneurs.
----

* *Kafka*
* *Hexagonal architecture* (with DDD)
* *Kubernetes* and its tools like *Helm*, *Nexus*, *Skaffold*

== Misc

.Scène / format vidéo utilisé par le salon pour l'enregistrement des talks
image::voxxed_video_scene_format.jpg[]